#### var定义的name属性在不同环境中的表现

下面的代码在浏览器环境中会`name`属性不是`undefined`，这是因为`window`对象上有`name`属性
```html
<body>
    <script>
        console.log(a) // undefined
        var a = 'aa'

        console.log(name); // name
        var name = 'name'
    </script>
</body>
```
在Node环境或者纯js引擎中执行以下代码，结果都是`undefined`

```javascript
console.log(a) // undefined
var a = 'aa'

console.log(name); // undefined
var name = 'name'

```

#### var与let的不同

1.var会声明提前

2.var没有作用域，let有块级作用域

```javascript
function fn(){
    for(var i=0;i<5;i++){}
    console.log(i)
}
fn() //5
```

```javascript
function fn(){
    for(let i=0;i<5;i++){}
    console.log(i)
}
fn() //ReferenceError: i is not defined
```

3.var变量可以重复声明，容易造成全局变量覆盖；let 不能重复声明

#### 深拷贝与浅拷贝

引用类型的变量赋值指向的内存是同一块，因此需要深拷贝，重新申请内存

##### 一维数组拷贝

可以直接用扩展运算符

```javascript
let arr1 = [1,3,4]
let arr2 = [...arr1]
```

拓展运算符并不能解决嵌套引用类型的问题，只能拷贝一层

###### json对象的简单深拷贝

```javascript
let obj = {
    name:'flten'
}

let obj2 = let obj = {
    name:'flten'
}

let obj2 = JSON.parse(JSON.stringify(obj))
```

##### 基本递归深拷贝

注意：for...in 循环包括了`继承的属性`，不过可以通过`hasOwnProperty`来进行判断，筛掉原型上拷贝的对象

```javascript
function deepClone(source){
    const target = source.constructor === Array ? []:{};
    for (const key in source) {
        if (Object.hasOwnProperty.call(source, key)) {
            let element = source[key]
            if(element && typeof element === 'object'){
                target[key] = deepClone(element)
            }else{
                target[key] = source[key]
            }
        }
    }
    return target
}
```
存在的问题：

1.无法拷贝`函数`、`undefined`、`symbol`

2.日期对象`Date`等特殊对象的`type of`判断也是`object`

3.无法处理循环引用的对象

#### 在浏览器中输入url并回车后发生了什么

1.DNS域名解析

DNS是域名与IP相互映射的分布式数据库服务器，从 DNS 得到服务器的真正IP地址

第一次访问会将解析的 IP 缓存在本地，第二次访问会先读取本地缓存，检测缓存是否有效

2.建立连接-TCP三次握手

(1)

(2)

(3)

3.得到服务端数据，进行渲染

4.断开连接-TCP四次挥手

#### 性能优化

##### 页面加载性能：

对用户体验至关重要

1.减少http请求(雪碧图、文件合并)

2.减少文件大小(资源压缩、图片压缩、代码压缩)，使用 SVG 代替图片

3.CDN 静态资源缓存

4.SSR 服务端渲染，预渲染

5.用js控制图片异步和懒加载，而不是发起请求

6.分包(加快首页加载)，按需加载

7.使用缓存策略：强制缓存+协商缓存

8.协议升级到 HTTP2，TCP/TLS连接复用

###### 动画与操作性能：

1.减少 DOM 操作，避免重排重绘

优先使用`translate`和定位，而不是 DOM 操作。因为`translate`脱离正常文档流，不会影响 DOM

2.操作量很大的DOM，使用文档碎片

##### 内存占用

##### 电量消耗

游戏需要考虑

#### 实现一个图片懒加载

1.图片的`src`属性上放临时图片，而在自定义的`data-src`上放真正的图片地址

2.计算视口高度及滚动高度，确认图片加载时机

```javascript
// notes/JavaScript/懒加载.html
let imgsNum = document.getElementsByTagName("img").length;
let imgs = document.getElementsByTagName("img");
lazyLoad()
window.onscroll = lazyLoad
function lazyLoad(){
    // 设备视口高度,可视区域
    let seeHeight = document.documentElement.clientHeight;
    // 滚动条距页面顶部高度
    let scrollTop = document.documentElement.scrollTop || document.body.scrollTop
    for (let index = 0; index < imgsNum; index++) {
        const img = imgs[index];
        if(img.offsetTop < seeHeight+scrollTop){
            if(img.getAttribute("src") === "./test.png"){
                img.src = img.getAttribute("data-src")
            }
        }
    }
}
```

#### 性能体系

指标体系

#### CSS 加载是否会造成阻塞？


