
### 堆栈内存

堆内存：存储对象类型的值

栈内存：代码执行；存储声明的变量及基础类型的值

#### 堆栈内存的初始化状态

1. 默认在堆内存中开辟一个堆内存空间存储浏览器为js提供的 API，即 GO 全局对象
2. 代码执行都放在执行上下文中进行，默认在栈内存中创建全局执行上下文EC，并且全局执行上下文永远在栈底部不出栈。EC 中会创建一个GO 全局变量对象，存储代码中定义的全局变量。

#### 代码执行过程中的变量存储
   
1. 全局上下文中，用`var`和`function`声明的变量会直接存储在 GO 中。对于函数会创建 AO 活动对象，对于其他变量声明会存储在 VO 变量对象中。
2. 函数创建：(1)为此开辟内存空间，并创建作用域`[[scope]]`(在哪个上下文中创建的，其作用域就是哪个)；(2)存储函数作为对象的基本属性`name`(函数名)，`length`(形参个数)，`prototype`，`__proto__`；(3)对于函数中的代码作为字符串存储；将空间地址赋值给栈中存储的变量名
3. 函数执行：函数是可执行对象。(1)创建私有的函数执行上下文，并创建自己的 AO 变量对象，用于存储函数中声明的私有变量；(2)初始化作用域链`<函数上下文，函数作用域>`；(3)初始化`this`；(4)初始化`arguments`；(4)形参赋值，存储在AO 对象中；(5)变量提升；(6)代码执行；(7)上下文的回收释放

#### 函数执行的堆栈内存

```javascript
let x = [12, 23];
const fn = function(y){
    y[0] = 100;
    y = 100;
    y[1] = 200;
    console.log(y);
};
fn(x);
console.log(x)

/*
100
[ 100, 23 ]
*/
```

1. `let x = [12, 23];`，为`[12, 23]`在堆内存中开辟空间，假设地址为`A`,在栈内存中创建变量`x`,并将`x`指向内存地址 A
2. `const fn = function(y){...}`，为`function(y){...}`在堆内存中开辟空间，假设地址为`B`，并存储代码字符串及其属性值。

#### 联等赋值与成员访问优先级的问题

```javascript
let a = {n:1}
let b = a
a.x = a = {n:2}
console.log(a.x) // undefined
console.log(b) // { n: 1, x: { n: 2 } }
```

1. `let a = {n:1}`，对`{n:1}`在堆内存中开辟空间进行存储，在栈中声明`a`变量，假设内存地址为 A,并将堆内存地址赋给`a`，让`a`指向改内存地址A。
2. `let b = a`，在栈中声明`b`变量，并将`a`所指向的堆内存地址赋给`b`，现在`a`和`b`都指向`{n:1}`所在堆内存地址A。
3. `a.x = a = {n:2}`，先处理等号右边的值。为`{n:2}`在堆内存中开辟空间进行存储，假设内存地址为 B。但对于`a.x`，它是成员访问，`成员访问的优先级比赋值优先级高`，即比`a={n:2}`优先级高。 因此先执行`a.x={n:2}`，即`a.x`指向内存 B。此时`a`和`b`共同指向的内存地址 A 中存储的数据为`{n:1,x:{n:2}}`。再执行`a={n:2}`，将`a`指向内存地址 B。
4. `console.log(a.x)`，`a`指向的内存 B中存储的值为`{n:2}`，没有`x`属性，因为为`undefined`
5. `console.log(b)`，`b`指向的内存 A 中存储的数据为`{n:1,x:{n:2}}`