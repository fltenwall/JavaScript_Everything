
#### 变量提升

浏览器开辟内存(栈内存/执行上下文/作用域)供js执行代码、存储变量(变量存储区)及基本数据类型的值(值存储区)。最先创建的作用域为全局作用域


词法解析阶段，会将`var`声明及`function`进行变量提升。对于`var`定义的变量，只是进行提升声明，并不赋值，默认值为`undefined`。对于`function`定义的函数会进行声明且赋值,开辟一个新的内存空间，将代码字符串内容存储在堆内存中。

```javascript
console.log(sum(10, 20)) // 30
function sum(a,b){ return a + b }
```

#### 带var与不带var的区别

1. 但是如果以函数表达式的方式声明函数，即将函数赋值给一个变量，则只会对该变量进行变量提升。

下面的代码会报错，因为词法解析阶段只对`var sum`进行了提前声明，并未进行赋值，后面的函数体也不会被关联到`sum`。

```javascript
console.log(sum(10, 20)) // TypeError: sum is not a function
var sum = function(a,b){ return a + b }
```

2. 在`全局作用域`下，对于普通变量来说，不用`var`声明，不是变量声明。`a=13`只是一个属性赋值，浏览器环境中，相当于`window.a=13`

```javascript
console.log(a) // ReferenceError: a is not defined
a = 13
console.log(a)
```

```javascript
a = 13
console.log(window.a === a) // true
```

3.浏览器环境中，在`全局作用域`下用`var`声明的变量是全局变量，会挂在全局对象`window`上。

```javascript
var a = 20
console.log(a === window.a) // true
```

总结：浏览器环境中，在`全局作用域`下，无论使用`var`或者不使用`var`的声明都是挂载在全局对象window上。区别在于不使用`var`的声明不是变量声明，只是给window添加属性。

#### 执行流程

开辟栈内存->创建全局作用域->词法解析->变量提升->代码进栈执行->变量值存储在值存储区，并将变量和值进行关联->

由于 js是先进行词法解析，因此下面整个代码不会执行，因为在词法解析阶段就已经出现了语法错误，不会再往下执行。

#### 变量重复定义的问题

```javascript
console.log('aaa')
let a = 1
var a = 2
//SyntaxError: Identifier 'a' has already been declared
```

而let重复声明不是语法错误，只有执行到的时候会报错。因此下面的代码第一行会执行输出

```javascript
console.log('aaa')
console.log(a)
let a = 10
/*
aaa
ReferenceError: Cannot access 'a' before initialization
*/
```
函数定义也可以被重复声明(覆盖)

```javascript
function fn(){console.log(1)}
var fn = function(){console.log(3)}
fn() // 3
```

#### 变量提升与重复声明

```javascript
fn()
function fn(){console.log(1)}
fn()
function fn(){console.log(2)}
fn()
var fn = function(){console.log(3)}
fn()
function fn(){console.log(4)}
fn()
function fn(){console.log(5)}
fn()

/*
5
5
5
3
3
3
*/
```

词法解析阶段，扫描代码，并进行变量提升：

1.`fn()`没有`var`或者`function`声明，不再词法解析阶段进行变量提升。

2.扫描到`function fn(){console.log(1)}`时，创建堆内存 A1，由于是`function`函数定义，声明变量`fn`,并进行赋值，将`fn`指向内存`A1`的地址

3.`fn()`没有`var`或者`function`声明，不再词法解析阶段进行变量提升。

4.扫描到`function fn(){console.log(2)}`时，创建堆内存 A2，不再重复声明，但要重新进行赋值，将`fn`指向内存`A2`地址

5.`fn()`没有`var`或者`function`声明，不再词法解析阶段进行变量提升。

6.扫描到`var fn = function(){console.log(3)}`，只对`var fn`进行变量提升，而不赋值；但`fn`已存在，不再重复声明。

7.`fn()`没有`var`或者`function`声明，不再词法解析阶段进行变量提升。

8.扫描到`function fn(){console.log(4)}`时，创建堆内存 A4，不再重复声明，但要重新进行赋值，将`fn`指向内存`A4`地址

9.`fn()`没有`var`或者`function`声明，不再词法解析阶段进行变量提升。

10.扫描到`function fn(){console.log(5)}`时，创建堆内存 A4，不再重复声明，但要重新进行赋值，将`fn`指向内存`A5`地址

11.`fn()`没有`var`或者`function`声明，不再词法解析阶段进行变量提升。


因此，变量提升结束时，`fn`指向的是存储代码`console.log(5)`的堆内存地址 A5。

代码执行阶段：

1.`fn()`开始执行，`fn`指向的是存储代码`console.log(5)`的堆内存地址 A5。取出代码进行执行栈执行代码，并输出 5

2.`function fn(){console.log(1)}`词法解析阶段已经做了变量提升，不再处理。

3.`fn()`开始执行，`fn`指向的是存储代码`console.log(5)`的堆内存地址 A5。取出代码进行执行栈执行代码，并输出 5

4.`function fn(){console.log(2)}`词法解析阶段已经做了变量提升，不再处理。

5.`fn()`开始执行，`fn`指向的是存储代码`console.log(5)`的堆内存地址 A5。取出代码进行执行栈执行代码，并输出 5

6.`var fn = function(){console.log(3)}`词法解析阶段只对`fn`进行了变量提升，但未做赋值。此时开始赋值操作，将变量`fn`指向存储代码`console.log(3)`的堆内存地址 A3

7.`fn()`开始执行，`fn`指向的是存储代码`console.log(3)`的堆内存地址 A3。取出代码进行执行栈执行代码，并输出 3

8.`function fn(){console.log(4)}`词法解析阶段已经做了变量提升，不再处理。

9.`fn()`开始执行，`fn`指向的是存储代码`console.log(3)`的堆内存地址 A3。取出代码进行执行栈执行代码，并输出 3

10.`function fn(){console.log(5)}`词法解析阶段已经做了变量提升，不再处理。

11.`fn()`开始执行，`fn`指向的是存储代码`console.log(3)`的堆内存地址 A3。取出代码进行执行栈执行代码，并输出 3

因此答案是：5 5 5 3 3 3 

