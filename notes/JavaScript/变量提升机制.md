
#### 变量提升

浏览器开辟内存(栈内存/执行上下文/作用域)供js执行代码、存储变量(变量存储区)及基本数据类型的值(值存储区)。最先创建的作用域为全局作用域


词法解析阶段，会将`var`声明及`function`进行变量提升。对于`var`定义的变量，只是进行提升声明，并不赋值，默认值为`undefined`。对于`function`定义的函数会进行声明且赋值,开辟一个新的内存空间，将代码字符串内容存储在堆内存中。

```javascript
console.log(sum(10, 20)) // 30
function sum(a,b){ return a + b }
```

#### 带var与不带var的区别

1. 但是如果以函数表达式的方式声明函数，即将函数赋值给一个变量，则只会对该变量进行变量提升。

下面的代码会报错，因为词法解析阶段只对`var sum`进行了提前声明，并未进行赋值，后面的函数体也不会被关联到`sum`。

```javascript
console.log(sum(10, 20)) // TypeError: sum is not a function
var sum = function(a,b){ return a + b }
```

2. 在`全局作用域`下，对于普通变量来说，不用`var`声明，不是变量声明。`a=13`只是一个属性赋值，浏览器环境中，相当于`window.a=13`

```javascript
console.log(a) // ReferenceError: a is not defined
a = 13
console.log(a)
```

```javascript
a = 13
console.log(window.a === a) // true
```

3.浏览器环境中，在`全局作用域`下用`var`声明的变量是全局变量，会挂在全局对象`window`上。

```javascript
var a = 20
console.log(a === window.a) // true
```

总结：浏览器环境中，在`全局作用域`下，无论使用`var`或者不使用`var`的声明都是挂载在全局对象window上。区别在于不使用`var`的声明不是变量声明，只是给window添加属性。

#### 执行流程

开辟栈内存->创建全局作用域->词法解析->变量提升->代码进栈执行->变量值存储在值存储区，并将变量和值进行关联->

由于 js是先进行词法解析，因此下面整个代码不会执行，因为在词法解析阶段就已经出现了语法错误，不会再往下执行。

```javascript
console.log('aaa')
let a = 1
var a = 2
//SyntaxError: Identifier 'a' has already been declared
```

而let重复声明不是语法错误，只有执行到的时候会报错。因此下面的代码第一行会执行输出

```javascript
console.log('aaa')
console.log(a)
let a = 10
/*
aaa
ReferenceError: Cannot access 'a' before initialization
*/
```



