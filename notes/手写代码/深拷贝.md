### 深拷贝与浅拷贝

引用类型的变量赋值指向的内存是同一块，因此需要深拷贝，重新申请内存

##### 一维数组拷贝

可以直接用扩展运算符

```javascript
let arr1 = [1,3,4]
let arr2 = [...arr1]
```

拓展运算符并不能解决嵌套引用类型的问题，只能拷贝一层

###### json对象的简单深拷贝

问题：

1.函数、日期、正则对象都会出现问题(会变为字符串并且变形)

2.不能解决循环引用问题

```javascript
let obj = {
    name:'flten'
}

let obj2 = let obj = {
    name:'flten'
}

let obj2 = JSON.parse(JSON.stringify(obj))
```

##### 基本递归深拷贝

注意：for...in 循环包括了`继承的属性`，不过可以通过`hasOwnProperty`来进行判断，筛掉原型上拷贝的对象

```javascript
function deepClone(source){
    const target = source.constructor === Array ? []:{};
    for (const key in source) {
        if (Object.hasOwnProperty.call(source, key)) {
            let element = source[key]
            if(element && typeof element === 'object'){
                target[key] = deepClone(element)
            }else{
                target[key] = source[key]
            }
        }
    }
    return target
}
```
存在的问题：

1.无法拷贝`函数`、`undefined`、`symbol`

2.日期对象`Date`等特殊对象的`type of`判断也是`object`

3.无法处理循环引用的对象

##### 处理其他类型

```javascript
function deepClone(source){
    // 非引用类型直接返回
    if(source === null || typeof source !== 'object') return source
    // 单独处理RegExp和Date
    if(source instanceof RegExp) return new RegExp(source)
    if(source instanceof Date) return new Date(source)
    if(source instanceof Set) {
        const newSet = new Set()
        for(const item of source){
            newSet.add(deepClone(item))
        }
        return newSet
    }
    if(typeof source === 'function') return source

    // 克隆的对象和之前的结果保持一样的所属类
    const target = new source.constructor;
    for (const key in source) {
        if (Object.hasOwnProperty.call(source, key)) {
            let element = source[key]
            target[key] = deepClone(element)
        }
    }
    return target
}
```

问题：

1. 没有解决循环引用问题

2. 其他特殊类型要一一处理判断

3. 对于`Symbol`，作为属性的值时，它的`typeof`结果为`symbol`，没有被考虑到
4. 对于`Symbol`，作为属性时，它不会被`for...in`遍历出来，也没有被考虑到

##### 考虑Symbol作为属性值及属性的情况

```javascript
function deepClone(source){
    // 对值是 Symbol 类型的属性进行判断
    if(typeof source === 'symbol') {
        return new Symbol(source.description)
    }
    // 非引用类型直接返回
    if(source === null || typeof source !== 'object') return source
    // 单独处理RegExp和Date
    if(source instanceof RegExp) return new RegExp(source)
    if(source instanceof Date) return new Date(source)
    if(source instanceof Set) {
        const newSet = new Set()
        for(const item of source){
            newSet.add(deepClone(item))
        }
        return newSet
    }
    if(typeof source === 'function') return source

    // 克隆的对象和之前的结果保持一样的所属类
    const target = new source.constructor;
    for (const key in source) {
        if (Object.hasOwnProperty.call(source, key)) {
            let element = source[key]
            target[key] = deepClone(element)
        }
    }
    // 处理 Symbol 作为对象属性的情况
    const symbolKeys = Object.getOwnPropertySymbols(source)
    for (const symbolKey of symbolKeys) {
        target[Symbol(symbolKey.description)] = deepClone(source[symbolKey])
    }
    return target
}
```

问题：

1. 没有解决循环引用问题

2. 其他特殊类型要一一处理判断

##### 考虑循环引用问题

循环引用如果在深拷贝时不处理会造成栈溢出。

```javascript
let map = new Map()
function deepClone(source){
    // 对值是 Symbol 类型的属性进行判断
    if(typeof source === 'symbol') {
        return new Symbol(source.description)
    }
    // 判断循环引用
    if(map.get(source)){
        return map.get(source)
    }
    // 非引用类型直接返回
    if(source === null || typeof source !== 'object') return source
    // 单独处理RegExp和Date
    if(source instanceof RegExp) return new RegExp(source)
    if(source instanceof Date) return new Date(source)
    if(source instanceof Set) {
        const newSet = new Set()
        for(const item of source){
            newSet.add(deepClone(item))
        }
        return newSet
    }
    if(typeof source === 'function') return source

    // 克隆的对象和之前的结果保持一样的所属类
    const target = new source.constructor;
    // 保持当前对象为key，为判断循环引用做准备
    map.set(source,target)
    for (const key in source) {
        if (Object.hasOwnProperty.call(source, key)) {
            let element = source[key]
            target[key] = deepClone(element)
        }
    }
    // 处理 Symbol 作为对象属性的情况
    const symbolKeys = Object.getOwnPropertySymbols(source)
    for (const symbolKey of symbolKeys) {
        target[Symbol(symbolKey.description)] = deepClone(source[symbolKey])
    }
    return target
}
```

问题：

1. 增加了额外的map，并且对原对象形成了强引用

2. 增加了全局变量

3. 其他特殊类型要一一处理判断

```javascript

function deepClone(source, map = new WeakMap()){
    // 对值是 Symbol 类型的属性进行判断
    if(typeof source === 'symbol') {
        return new Symbol(source.description)
    }
    // 判断循环引用
    if(map.get(source)){
        return map.get(source)
    }
    // 非引用类型直接返回
    if(source === null || typeof source !== 'object') return source
    // 单独处理RegExp和Date
    if(source instanceof RegExp) return new RegExp(source)
    if(source instanceof Date) return new Date(source)
    if(source instanceof Set) {
        const newSet = new Set()
        for(const item of source){
            newSet.add(deepClone(item))
        }
        return newSet
    }
    if(typeof source === 'function') return source

    // 克隆的对象和之前的结果保持一样的所属类
    const target = new source.constructor;
    // 保持当前对象为key，为判断循环引用做准备
    map.set(source,target)
    for (const key in source) {
        if (Object.hasOwnProperty.call(source, key)) {
            let element = source[key]
            target[key] = deepClone(element, map)
        }
    }
    // 处理 Symbol 作为对象属性的情况
    const symbolKeys = Object.getOwnPropertySymbols(source)
    for (const symbolKey of symbolKeys) {
        target[Symbol(symbolKey.description)] = deepClone(source[symbolKey], map)
    }
    return target
}
```

核心：递归调用时，将`map`传入，这样每一次递归调用使用的都是同一个`map`.这样在函数执行结束时，`map`会作为参数随着函数一起被销毁。

问题：

1. 其他特殊类型要一一处理判断