
通过`jsvu`可以安装 V8:

`d8 --print--ast demo.js`可以打印出代码抽象语法树

`d8 --print--scope demo.js`可以打印出代码作用域

V8执行流程：

采用解析和编译两种方式，称为JIT技术

1. 由解析器生成抽象语法树和相关的作用域
2. 根据 AST 和作用域生成字节码，字节码是介于 AST 和机器码的中间代码
3. 解析器执行字节码


函数是懒解析的，只有执行时可以进行内部解析

## V8 内存管理

V8 本身也是程序，它本身也会申请内存，它申请的内存称为常驻内存，而它又将内存分为堆和栈

## 栈内存

1. 栈用于存放JS 中的基本类型和引用类型指针
2. 栈空间是连续的，增加删除只需要移动指针，操作速度很快
3. 栈空间是有限的，若超出栈空间内存，会抛出栈空间溢出错误
4. 栈是在执行函数时创建的，函数执行完毕后，栈销毁

栈的内存回收机制

1. 栈中压入一个全局执行上下文，长驻栈底，不会销毁
2. 每个函数执行时都会创建一个执行上下文(存储函数变量、文法环境、词法环境的对象)
3. 函数执行结束，立马销毁
4. 当函数中存在闭包的情况下，函数的执行上下文会被销毁。函数内部被外部引用的变量会被放入堆内存中保存。

## 堆内存

内存不连续，需要大的内存空间，使用堆

在 32 位系统下是1.4G，64 位下分配 2G

### 堆内存分类

#### 新生代

新生代内存`new space`会保存一些生命周期较短的对象，但新创建的对象无法确定其生命周期，因此会先放入新生代内存中。不过它只有 32M 大小

#### 老生代

新生代内存`old space`会保存一些生命周期较长的对象。如果判断长短？两个周期的垃圾回收之后，如果数据会在新生代内存中，则将其放入老生代内存。

#### 代码空间(code space)

运行时代码空间，存放 JIT已编译代码，是唯一拥有执行权限的内存

#### 大对象空间(large object space)

专门存储大对象，新生代存放不下，单独分配内存存储。GC 不会对其进行垃圾回收

#### Map Space

存放对象的Map 信息，即隐藏类，它是为了提升对象属性的访问速度的。V8 会为每一个对象创建一个隐藏类，记录对象的属性布局，包括所有属性和偏移量。

## 垃圾回收机制

何为垃圾？程序执行结束后不再需要的数据。更准确一点，从`根节点GCRoot`访问不到的就是内存垃圾。

### 新生代垃圾回收

新生代中有`From Space`和`To Space`两块区域，新对象会放入`From Space`中，如果内存满了就开始垃圾回收。

#### 

 1. 从根节点出发，广度优先遍历所有能到达的对象，将存活的对象(可以访问到的对象)按顺序复制到`To Space`内存中
 2. 遍历完成后，清空`To Space`内存
 3. `From Space`和`To Space`角色互换

### 老生代垃圾回收

#### 标记清除

#### 









