
### 为什么是链表？

#### 数组的问题

1.连续内存，超出需扩容

2.开头和中间插入、删除数据的成本很高

#### 特点

1.非连续，通过引用(指针)连接，可以实现内存动态管理

2.插入和删除效率奇高

#### 缺点

1.访问元素效率低，需要从头遍历

### 实现链表

#### 节点类

链表是由节点组成的，因此我们首先需要一个节点类来能够创建节点，然后再通过链表来管理节点。

节点类的实现

```typescript
class Node<T>{
    value:T
    next:Node<T> | null = null
    constructor(value:T){
        this.value=value
    }
}
```

#### 链表类

链表是对节点的管理，因此我们需要封装一系列的方法来对类进行操作

首先每个链表都需要有一个指针执行链表的头结点，通过头结点我们才能够对链表进行访问；初次之后我们最好有一个变量记录链表的长度。

```typescript
class Linkedlist<T>{
    private head:Node<T> | null = null
    private size:number = 0

    get length(){
        return this.size
    }
}
```

这是最基础的链表类的结构，然后我们就需要添加一系列的方法来进行操作。

##### 添加节点

一开始链表为空，一切的操作都需要以添加节点为基础，有了节点我们才能进行操作。

1.需要首先判断链表是否为空，如果为空那么添加进去的第一个节点将成为头结点

2.若链表不为空，那就是往链表尾部添加，而我们无法通过索引获取到尾部元素，只能通过遍历每个元素才能找到尾部节点。

```typescript
    append(value:T){
        // 创建新节点
        const newNode = new Node(value)
        // 链表为空
        if(!this.head) {
            this.head = newNode
        }else{
            let current = this.head
            while(current.next){
                current = current.next
            }
            current.next = newNode
        }
        this.size++  
    }
```

这段代码的重点在于对链表的遍历，一直循环直到有元素的`next`指针为空，即找到了尾部节点。因为只有尾部节点的`next`为空。


### 代码优化


### 接口的重新设计
